+++
title = 'Data Centric Layered Sop（FastAPI + SQLModel + Alembic SOP）'
date = 2025-08-23T08:00:00+12:00
draft = true
tags = ["DTO", "DAO", "FastAPI", ""]
description = "面向中小型到企业级后端的可维护、可演进、可测试分层方案。技术栈：FastAPI + SQLModel（Pydantic v2）+ Alembic。"
+++

实际上都能通过某中规则生成。那么LLM到底给我们带来了什么？主要是帮助我更快的思考。
代码文件结构和实际分层结构是2回事儿
# 以数据为中心的分层实践SOP(FastAPI + SQLModel + Alembic )

> Goal: clear boundaries, stable contracts, and smooth evolution and testing. Stack: FastAPI (Pydantic v2), SQLModel (integration of SQLAlchemy ORM and Pydantic), Alembic (schema migrations).

## 1. Standard structure and responsibilities from a data perspective

Runtime call chain
- Router -> Service -> DAO -> Model -> DB

Type and contract relationships
- Router uses DTO/Schemas as the request and response contract for validation, projection, and OpenAPI.
- Service does not depend on DTO/Schemas. It receives domain input produced by the Router after validation and maps domain input to Model before calling DAO.
- DAO depends only on Model and Session. DAO never depends on DTO/Schemas.
- Model and DTO/Schemas relate by mapping and projection only. There is no call relationship.

Layer responsibilities
- Router: HTTP boundary, auth, request validation with DTO, response projection with response_model, OpenAPI. No business logic.
- Service: business orchestration and rules, transaction control, cross DAO aggregation, mapping from domain input to Model and vice versa, uniform error translation to Problem Details (RFC 9457).
- DAO (or repository): pure data access using Session and Model for CRUD and query. No business logic.
- Model (SQLModel or SQLAlchemy ORM): table structure, constraints, indexes, defaults, relationships.
- DTO/Schemas (Pydantic or SQLModel based): request and response contract, input allow list, output projection, versioning.

Glossary
- DAO: Data Access Object. Encapsulates persistence operations against the database.
- DTO: Data Transfer Object. Defines Create, Update, and Read shapes exposed to external clients.
- Projection: converting internal Model shape to the minimal public Read DTO shape.
- Problem Details (RFC 9457): standard error format fields type, title, status, detail, instance.
- SQLModel value: define field rules once in a Base and reuse in both ORM Model and DTO to avoid duplication.

## 2. Text responsibility flow diagram with explicit DTO block

```
Legend:
-> runtime call
--> type or contract reference
<-> mapping or projection only (no call)

HTTP JSON
  |
  v
[Router] --> uses DTO/Schemas for request validation and response projection
  |
  v
[Service] maps domain input to Model, orchestrates business, controls transactions
  |
  v
[DAO] pure data access with Session and Model
  |
  v
[Model] ORM mapping to DB
  |
  v
DB

Right side DTO block and relationships
[DTO/Schemas]
  supports Router: request validation and response projection
  supports Model: Model <-> DTO mapping and projection
  not imported by DAO
  not required by Service in this standard

Cross relationships summary
[Router] --> [DTO/Schemas]
[Service] x no dependency on DTO/Schemas
[DAO] x no dependency on DTO/Schemas
[Model] <-> [DTO/Schemas]
```

## 3. Project layout for FastAPI with SQLModel and Alembic

```
app/
  api/
    v1/
      company.py              Router: DTO input and response_model, auth, calls Service
  services/
    company_service.py        Service: no DTO dependency; business, transactions, mapping DTO->Model, calls DAO
  dao/
    company_dao.py            DAO: pure data access with Session and Model
  models/
    __init__.py               from .company import Company for Alembic discovery
    company.py                SQLModel ORM and Base field reuse
  schemas/
    company.py                DTO: CompanyCreate, CompanyUpdate, CompanyRead; reuse Base; input DTO uses extra='forbid'
  db/
    base.py                   engine and SQLModel.metadata binding
    deps.py                   Depends(get_session) for FastAPI
    config.py                 database URL and settings
  core/
    security.py               auth and context helpers
    errors.py                 Problem Details helpers
  tests/
    conftest.py               TestClient and temporary DB or rollback fixtures
    test_company_api.py       API contract and error tests
    test_company_service.py   business branches, transactions, mapping correctness
    test_company_dao.py       DAO CRUD, constraints, and queries

alembic/
  versions/                   migration scripts
  env.py                      binds SQLModel.metadata and imports app.models.*
```

## 4. Standard implementation steps (SOP)

0. Planning and naming
- Define table, index, and constraint names, for example uq_company_name and ix_company_name.
- Centralize field rules in a SQLModel Base so rules are written once and reused by ORM and DTO.

1. Define Model (ORM)
- Create app/models/object.py with SQLModel(table=True) and specify constraints, indexes, relationships, and server defaults.
- Ensure the model is imported in app/models/__init__.py so Alembic autogenerate can discover it.

2. Create and review migration with Alembic
- Generate migration
  uv run alembic revision --autogenerate -m "add object table"
- Manually review before applying
  server_default is correct for timestamps and booleans
  constraints and indexes exist as required; add op.create_index or unique constraints when needed
  enum handling on PostgreSQL is correct or use CHECK as appropriate
- Apply migration
  uv run alembic upgrade head

3. Define DTO (Schemas)
- Create app/schemas/object.py with Create, Update, and Read DTO types.
- Input DTO must use extra='forbid' to block unknown fields.
- Read DTO contains only public fields required by clients and uses from_attributes=True for projection.
- With SQLModel reuse the Base field definition by inheriting Base in Create and Update DTO.

4. Implement DAO
- Implement minimal CRUD and query functions that accept Session and Model and return Model instances.
- Do not implement business logic. Do not import DTO or FastAPI types.
- Use select queries. With SQLModel prefer session.exec(select(...)).all().

5. Implement Service
- Service does not depend on DTO. It receives domain input produced by Router after DTO validation, for example a dict or a small domain input type.
- Map domain input to Model inside Service, call DAO, control transactions, and translate failures to Problem Details.
- Return a Model or a domain output that Router will project to Read DTO.

6. Implement Router
- Use Create and Update DTO for request bodies and response_model with the Read DTO for responses.
- Inject Session through Depends(get_session). Do not implement business logic.
- Pass domain input to Service, for example payload.model_dump().
- Let response_model perform the final projection and filtering to avoid leaking internal fields.

7. Tests
- DAO tests: CRUD, unique and index behavior, and constraint behavior using a temporary DB or transaction rollback fixtures.
- Service tests: correct mapping from domain input to Model, transaction commit and rollback paths, error translation to Problem Details, and business branches across DAOs.
- API tests: 422 validation from DTO, auth branches, pagination and sorting contracts, response_model projection hides internal fields, RFC 9457 error format.
- Smoke flow: Create then List then Update then List including edge cases such as duplicate names.

8. Regression and documentation
- In pull requests include migration summary, impact scope, and key test evidence.
- OpenAPI is authoritative for the contract because Router uses DTO and response_model.
- When breaking changes are required, introduce v2 DTO and routes and keep v1 for a migration period.
